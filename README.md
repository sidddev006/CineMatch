             CineMatch

Video Demo :

Description :

CineMatch: An Intelligent Movie Recommendation System
Discovering that elusive movie to watch has paradoxically become more difficult in the era of endless streaming choices. With thousands of movies at hand on multiple platforms, viewers waste more time searching than viewing. This paralysis by choice—scrolling infinitely through bland "Top 10" lists or algorithmic recommendations that fail to connect—prompted the invention of CineMatch, a Flask web application that penetrates the noise to provide truly outstanding movie suggestions.
The Core Problem
Conventional film discovery has two profound weaknesses. First, popularity-driven rankings promote blockbuster and trending movies and hide gems that could be ideal for a certain viewer. Second, unweighted rating systems are undeserving of trust: a documentary with 50 perfect critic reviews is worth something different than a popular comedy film with 50,000 favorable ratings. Subscribers require a system that reconciles critical success and user affirmation while excluding overly hyped mainstream fare and extremely niche features that have no wider appeal.
The Solution: Weighted Rating Algorithm
The innovation of CineMatch is its weighted rating formula, which assigns a score to a movie based on the following formula: (v/(v+m)) × R + (m/(v+m)) × C, where v represents vote count, R is average rating, m is the minimum votes threshold value (500), and C is the base quality score (8.0). This mathematical solution elegantly addresses the popularity-quality problem.
The algorithm works by requiring movies to have at least 450 votes before consideration, immediately filtering out extremely obscure content that might be critically praised but lack sufficient validation. The threshold of 500 votes in the formula creates a "credibility gate"—films need substantial audience engagement to rank highly. In the meantime, the 8.0 baseline keeps the system open to undiscovered gems who have fewer votes but whose rating is phenomenal, so it doesn't turn the system into mere popularity-based.
A case in point is a highly-rated indie movie with 600 votes at 9.5, which will trump a 50,000-vote mainstream blockbuster at 8.2 because the algorithm is able to detect true quality. Conversely, a film with only 100 votes and a perfect 10.0 rating won't dominate the results, as it lacks sufficient validation. This balance proved crucial during testing when a film titled "Nude" appeared in recommendations—a movie with suspiciously high ratings but minimal votes, exactly the kind of edge case the algorithm successfully filters out.
User Experience and Features
CineMatch prioritizes simplicity and personalization. Upon registration and login (protected with safe password hashing through Werkzeug), users are presented with a home dashboard that provides two avenues: look at their watchlist or find new films. The recommendation engine provides three optional filters—genre, runtime, and decade—to let users filter results by mood, time available, or nostalgic interest. Notably, if every filter is left blank, the system defaults to suggesting the very top-ranked movies in all genres, for users who just desire the best without limitation.
Search results are presented in a simple table layout with posters, titles, summaries, weighted scores, runtime, and release date. Every movie has an "Add to Watchlist" button (or badge if already on the list), fully integrated with the database. The watchlist functionality is an individual curation feature, allowing users to create a list of movies to be watched. It is easy to delete a movie from the watchlist, and importantly, the system retains search filters when adding movies—fixing a major UX flaw where adding a film would clear all the selections and require users to re-populate the recommendation form.
Technical Implementation
CineMatch utilizes The Movie Database (TMDB) API, which was selected for its extensive film information and high rate limits. The app initiates several API calls within a cycle of recommendations: an initial query of the /discover/movie endpoint with filter arguments, and separate calls to /movie/{id} to retrieve runtime information (which isn't present within discovery results). This two-layer process was approached with caution in terms of rate limiting and error handling to avoid API errors.
The backend, crafted in pure Flask and Python, handles user sessions, database queries (through CS50's SQL library for SQLite), and API request coordination. Three tables comprise the database schema: users (for authentication purposes), watchlist (for tracking user-movie relationships), and ratings (held for potential future extensions). Form handling employs both POST requests (initial queries) and GET requests with URL parameters (maintaining state following watchlist additions), with urllib.parse.urlencode building clean redirect URLs.
Impact and Learning
Building CineMatch gave firsthand experience with backend web development, RESTful API integration, database structure, and resolving real-world UX problems. The project takes film discovery from a tiresome browse through endless middling choices to a focused, algorithmic process that honors both critical excellence and audience endorsement. To users weary of scrolling through mile-long lists of mediocre choices, CineMatch offers what they need: reliably great recommendations worth their time.
